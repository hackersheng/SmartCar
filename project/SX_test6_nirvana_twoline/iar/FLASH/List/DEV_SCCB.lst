###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.3.8024/W32 for ARM        12/Jul/2016  22:02:52
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\whstarlit\Desktop\Smart_Car\project\SX_test6_nirvana_twoline\app\DEV_SCCB.c
#    Command line =  
#        C:\Users\whstarlit\Desktop\Smart_Car\project\SX_test6_nirvana_twoline\app\DEV_SCCB.c
#        -D LPLD_K60 -D USE_K60D10 -lCN
#        C:\Users\whstarlit\Desktop\Smart_Car\project\SX_test6_nirvana_twoline\iar\FLASH\List\
#        -lB
#        C:\Users\whstarlit\Desktop\Smart_Car\project\SX_test6_nirvana_twoline\iar\FLASH\List\
#        -o
#        C:\Users\whstarlit\Desktop\Smart_Car\project\SX_test6_nirvana_twoline\iar\FLASH\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config
#        D:\IAR\arm\INC\c\DLib_Config_Normal.h -I
#        C:\Users\whstarlit\Desktop\Smart_Car\project\SX_test6_nirvana_twoline\iar\..\app\
#        -I
#        C:\Users\whstarlit\Desktop\Smart_Car\project\SX_test6_nirvana_twoline\iar\..\..\..\lib\CPU\
#        -I
#        C:\Users\whstarlit\Desktop\Smart_Car\project\SX_test6_nirvana_twoline\iar\..\..\..\lib\common\
#        -I
#        C:\Users\whstarlit\Desktop\Smart_Car\project\SX_test6_nirvana_twoline\iar\..\..\..\lib\LPLD\
#        -I
#        C:\Users\whstarlit\Desktop\Smart_Car\project\SX_test6_nirvana_twoline\iar\..\..\..\lib\LPLD\HW\
#        -I
#        C:\Users\whstarlit\Desktop\Smart_Car\project\SX_test6_nirvana_twoline\iar\..\..\..\lib\LPLD\DEV\
#        -I
#        C:\Users\whstarlit\Desktop\Smart_Car\project\SX_test6_nirvana_twoline\iar\..\..\..\lib\LPLD\FUNC\
#        -I
#        C:\Users\whstarlit\Desktop\Smart_Car\project\SX_test6_nirvana_twoline\iar\..\..\..\lib\uCOS-II\Ports\
#        -I
#        C:\Users\whstarlit\Desktop\Smart_Car\project\SX_test6_nirvana_twoline\iar\..\..\..\lib\uCOS-II\Source\
#        -I
#        C:\Users\whstarlit\Desktop\Smart_Car\project\SX_test6_nirvana_twoline\iar\..\..\..\lib\FatFs\
#        -I
#        C:\Users\whstarlit\Desktop\Smart_Car\project\SX_test6_nirvana_twoline\iar\..\..\..\lib\FatFs\option\
#        -I
#        C:\Users\whstarlit\Desktop\Smart_Car\project\SX_test6_nirvana_twoline\iar\..\..\..\lib\USB\common\
#        -I
#        C:\Users\whstarlit\Desktop\Smart_Car\project\SX_test6_nirvana_twoline\iar\..\..\..\lib\USB\driver\
#        -I
#        C:\Users\whstarlit\Desktop\Smart_Car\project\SX_test6_nirvana_twoline\iar\..\..\..\lib\USB\descriptor\
#        -I
#        C:\Users\whstarlit\Desktop\Smart_Car\project\SX_test6_nirvana_twoline\iar\..\..\..\lib\USB\class\
#        -Ol -I D:\IAR\arm\CMSIS\Include\ -D ARM_MATH_CM4
#    List file    =  
#        C:\Users\whstarlit\Desktop\Smart_Car\project\SX_test6_nirvana_twoline\iar\FLASH\List\DEV_SCCB.lst
#    Object file  =  
#        C:\Users\whstarlit\Desktop\Smart_Car\project\SX_test6_nirvana_twoline\iar\FLASH\Obj\DEV_SCCB.o
#
###############################################################################

C:\Users\whstarlit\Desktop\Smart_Car\project\SX_test6_nirvana_twoline\app\DEV_SCCB.c
      1          /*!
      2           *     COPYRIGHT NOTICE
      3           *     Copyright (c) 2013,山外科技
      4           *     All rights reserved.
      5           *     技术讨论：山外论坛 http://www.vcan123.com
      6           *
      7           *     除注明出处外，以下所有内容版权均属山外科技所有，未经允许，不得用于商业用途，
      8           *     修改内容时必须保留山外科技的版权声明。
      9           *
     10           * @file       VCAN_SCCB.c
     11           * @brief      OV摄像头配置总线SCCB函数库
     12           * @author     山外科技
     13           * @version    v5.0
     14           * @date       2013-09-01
     15           */
     16          
     17          
     18          #include "include.h"
     19          
     20          
     21          static void SCCB_delay(uint16 i);
     22          
     23          /*!
     24           *  @brief      SCCB延迟函数
     25           *  @param      time    延时时间
     26           *  @since      v5.0
     27           */

   \                                 In section .text, align 2, keep-with-next
     28          static void SCCB_delay(volatile uint16 time)
     29          {
   \                     SCCB_delay: (+1)
   \   00000000   0xB401             PUSH     {R0}
   \   00000002   0xE004             B.N      ??SCCB_delay_0
     30              while(time)
     31              {
     32                  time--;
   \                     ??SCCB_delay_1: (+1)
   \   00000004   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000008   0x1E40             SUBS     R0,R0,#+1
   \   0000000A   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     33              }
   \                     ??SCCB_delay_0: (+1)
   \   0000000E   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD1F6             BNE.N    ??SCCB_delay_1
     34          }
   \   00000016   0xB001             ADD      SP,SP,#+4
   \   00000018   0x4770             BX       LR               ;; return
     35          
     36          /*!
     37           *  @brief      SCCB管脚配置
     38           *  @since      v5.0
     39           */

   \                                 In section .text, align 2, keep-with-next
     40          void SCCB_GPIO_init(void)
     41          {
   \                     SCCB_GPIO_init: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
     42            GPIO_InitTypeDef pta;
     43            /********用户可修改值 开始***********/
     44            pta.GPIO_PTx = PTA;
   \   00000004   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff000
   \   00000006   0x9001             STR      R0,[SP, #+4]
     45            pta.GPIO_Pins = GPIO_Pin12 | GPIO_Pin13;
   \   00000008   0xF44F 0x5040      MOV      R0,#+12288
   \   0000000C   0x9002             STR      R0,[SP, #+8]
     46            /********用户可修改值 结束***********/
     47            pta.GPIO_Dir = DIR_OUTPUT;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF88D 0x0010      STRB     R0,[SP, #+16]
     48            pta.GPIO_Output = OUTPUT_H;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF88D 0x0011      STRB     R0,[SP, #+17]
     49            pta.GPIO_PinControl = NULL;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x9003             STR      R0,[SP, #+12]
     50            LPLD_GPIO_Init(pta);
   \   0000001E   0xA901             ADD      R1,SP,#+4
   \   00000020   0xB084             SUB      SP,SP,#+16
   \   00000022   0x4668             MOV      R0,SP
   \   00000024   0x2214             MOVS     R2,#+20
   \   00000026   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000002A   0xBC0F             POP      {R0-R3}
   \   0000002C   0x.... 0x....      BL       LPLD_GPIO_Init
     51          }
   \   00000030   0xB007             ADD      SP,SP,#+28
   \   00000032   0xBD00             POP      {PC}             ;; return
     52          
     53          /*!
     54           *  @brief      SCCB起始信号
     55           *  @since      v5.0
     56           */

   \                                 In section .text, align 2, keep-with-next
     57          static uint8 SCCB_Start(void)
     58          {
   \                     SCCB_Start: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     59              SDA_H();
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x....             LDR.N    R1,??DataTable7_1  ;; 0x43fe0034
   \   00000006   0x6008             STR      R0,[R1, #+0]
     60              SCL_H();
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x....             LDR.N    R1,??DataTable7_2  ;; 0x43fe0030
   \   0000000C   0x6008             STR      R0,[R1, #+0]
     61              SCCB_DELAY();
   \   0000000E   0xF44F 0x70C8      MOV      R0,#+400
   \   00000012   0x.... 0x....      BL       SCCB_delay
     62          
     63              SDA_DDR_IN();
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x....             LDR.N    R1,??DataTable7_3  ;; 0x43fe02b4
   \   0000001A   0x6008             STR      R0,[R1, #+0]
     64              if(!SDA_IN())
   \   0000001C   0x....             LDR.N    R0,??DataTable7_4  ;; 0x43fe0234
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD104             BNE.N    ??SCCB_Start_0
     65              {
     66                  SDA_DDR_OUT();
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x....             LDR.N    R1,??DataTable7_3  ;; 0x43fe02b4
   \   00000028   0x6008             STR      R0,[R1, #+0]
     67                  return 0;   /* SDA线为低电平则总线忙,退出 */
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE016             B.N      ??SCCB_Start_1
     68              }
     69              SDA_DDR_OUT();
   \                     ??SCCB_Start_0: (+1)
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x....             LDR.N    R1,??DataTable7_3  ;; 0x43fe02b4
   \   00000032   0x6008             STR      R0,[R1, #+0]
     70              SDA_L();
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x....             LDR.N    R1,??DataTable7_1  ;; 0x43fe0034
   \   00000038   0x6008             STR      R0,[R1, #+0]
     71          
     72              SCCB_DELAY();
   \   0000003A   0xF44F 0x70C8      MOV      R0,#+400
   \   0000003E   0x.... 0x....      BL       SCCB_delay
     73              SCL_L();
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x....             LDR.N    R1,??DataTable7_2  ;; 0x43fe0030
   \   00000046   0x6008             STR      R0,[R1, #+0]
     74          
     75              if(SDA_IN())
   \   00000048   0x....             LDR.N    R0,??DataTable7_4  ;; 0x43fe0234
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD004             BEQ.N    ??SCCB_Start_2
     76              {
     77                  SDA_DDR_OUT();
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0x....             LDR.N    R1,??DataTable7_3  ;; 0x43fe02b4
   \   00000054   0x6008             STR      R0,[R1, #+0]
     78                  return 0;   /* SDA线为高电平则总线出错,退出 */
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xE000             B.N      ??SCCB_Start_1
     79              }
     80              //SDA_DDR_OUT();
     81              //SDA_L();
     82              //SCCB_delay();
     83              return 1;
   \                     ??SCCB_Start_2: (+1)
   \   0000005A   0x2001             MOVS     R0,#+1
   \                     ??SCCB_Start_1: (+1)
   \   0000005C   0xBD02             POP      {R1,PC}          ;; return
     84          }
     85          
     86          /*!
     87           *  @brief      SCCB停止信号
     88           *  @since      v5.0
     89           */

   \                                 In section .text, align 2, keep-with-next
     90          static void SCCB_Stop(void)
     91          {
   \                     SCCB_Stop: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     92              SCL_L();
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x....             LDR.N    R1,??DataTable7_2  ;; 0x43fe0030
   \   00000006   0x6008             STR      R0,[R1, #+0]
     93              //SCCB_DELAY();
     94              SDA_L();
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x....             LDR.N    R1,??DataTable7_1  ;; 0x43fe0034
   \   0000000C   0x6008             STR      R0,[R1, #+0]
     95              SCCB_DELAY();
   \   0000000E   0xF44F 0x70C8      MOV      R0,#+400
   \   00000012   0x.... 0x....      BL       SCCB_delay
     96              SCL_H();
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x....             LDR.N    R1,??DataTable7_2  ;; 0x43fe0030
   \   0000001A   0x6008             STR      R0,[R1, #+0]
     97              SCCB_DELAY();
   \   0000001C   0xF44F 0x70C8      MOV      R0,#+400
   \   00000020   0x.... 0x....      BL       SCCB_delay
     98              SDA_H();
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x....             LDR.N    R1,??DataTable7_1  ;; 0x43fe0034
   \   00000028   0x6008             STR      R0,[R1, #+0]
     99              SCCB_DELAY();
   \   0000002A   0xF44F 0x70C8      MOV      R0,#+400
   \   0000002E   0x.... 0x....      BL       SCCB_delay
    100          }
   \   00000032   0xBD01             POP      {R0,PC}          ;; return
    101          
    102          /*!
    103           *  @brief      SCCB应答信号
    104           *  @since      v5.0
    105           */

   \                                 In section .text, align 2, keep-with-next
    106          static void SCCB_Ack(void)
    107          {
   \                     SCCB_Ack: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    108              SCL_L();
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x....             LDR.N    R1,??DataTable7_2  ;; 0x43fe0030
   \   00000006   0x6008             STR      R0,[R1, #+0]
    109              SCCB_DELAY();
   \   00000008   0xF44F 0x70C8      MOV      R0,#+400
   \   0000000C   0x.... 0x....      BL       SCCB_delay
    110              SDA_L();
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x....             LDR.N    R1,??DataTable7_1  ;; 0x43fe0034
   \   00000014   0x6008             STR      R0,[R1, #+0]
    111              SCCB_DELAY();
   \   00000016   0xF44F 0x70C8      MOV      R0,#+400
   \   0000001A   0x.... 0x....      BL       SCCB_delay
    112              SCL_H();
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x....             LDR.N    R1,??DataTable7_2  ;; 0x43fe0030
   \   00000022   0x6008             STR      R0,[R1, #+0]
    113              SCCB_DELAY();
   \   00000024   0xF44F 0x70C8      MOV      R0,#+400
   \   00000028   0x.... 0x....      BL       SCCB_delay
    114              SCL_L();
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x....             LDR.N    R1,??DataTable7_2  ;; 0x43fe0030
   \   00000030   0x6008             STR      R0,[R1, #+0]
    115              SCCB_DELAY();
   \   00000032   0xF44F 0x70C8      MOV      R0,#+400
   \   00000036   0x.... 0x....      BL       SCCB_delay
    116          }
   \   0000003A   0xBD01             POP      {R0,PC}          ;; return
    117          
    118          /*!
    119           *  @brief      SCCB无应答信号
    120           *  @since      v5.0
    121           */

   \                                 In section .text, align 2, keep-with-next
    122          static void SCCB_NoAck(void)
    123          {
   \                     SCCB_NoAck: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    124              SCL_L();
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x....             LDR.N    R1,??DataTable7_2  ;; 0x43fe0030
   \   00000006   0x6008             STR      R0,[R1, #+0]
    125              SCCB_DELAY();
   \   00000008   0xF44F 0x70C8      MOV      R0,#+400
   \   0000000C   0x.... 0x....      BL       SCCB_delay
    126              SDA_H();
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x....             LDR.N    R1,??DataTable7_1  ;; 0x43fe0034
   \   00000014   0x6008             STR      R0,[R1, #+0]
    127              SCCB_DELAY();
   \   00000016   0xF44F 0x70C8      MOV      R0,#+400
   \   0000001A   0x.... 0x....      BL       SCCB_delay
    128              SCL_H();
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x....             LDR.N    R1,??DataTable7_2  ;; 0x43fe0030
   \   00000022   0x6008             STR      R0,[R1, #+0]
    129              SCCB_DELAY();
   \   00000024   0xF44F 0x70C8      MOV      R0,#+400
   \   00000028   0x.... 0x....      BL       SCCB_delay
    130              SCL_L();
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x....             LDR.N    R1,??DataTable7_2  ;; 0x43fe0030
   \   00000030   0x6008             STR      R0,[R1, #+0]
    131              SCCB_DELAY();
   \   00000032   0xF44F 0x70C8      MOV      R0,#+400
   \   00000036   0x.... 0x....      BL       SCCB_delay
    132          }
   \   0000003A   0xBD01             POP      {R0,PC}          ;; return
    133          
    134          /*!
    135           *  @brief      SCCB 等待应答
    136           *  @return     应答结果（0表示无应答，1表示有应答）
    137           *  @since      v5.0
    138           */

   \                                 In section .text, align 2, keep-with-next
    139          static int SCCB_WaitAck(void)
    140          {
   \                     SCCB_WaitAck: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    141              SCL_L();
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x....             LDR.N    R1,??DataTable7_2  ;; 0x43fe0030
   \   00000006   0x6008             STR      R0,[R1, #+0]
    142              //SDA_H();
    143              SDA_DDR_IN();
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x....             LDR.N    R1,??DataTable7_3  ;; 0x43fe02b4
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    144          
    145              SCCB_DELAY();
   \   0000000E   0xF44F 0x70C8      MOV      R0,#+400
   \   00000012   0x.... 0x....      BL       SCCB_delay
    146              SCL_H();
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x....             LDR.N    R1,??DataTable7_2  ;; 0x43fe0030
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    147          
    148              SCCB_DELAY();
   \   0000001C   0xF44F 0x70C8      MOV      R0,#+400
   \   00000020   0x.... 0x....      BL       SCCB_delay
    149          
    150              if(SDA_IN())           //应答为高电平，异常，通信失败
   \   00000024   0x....             LDR.N    R0,??DataTable7_4  ;; 0x43fe0234
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD007             BEQ.N    ??SCCB_WaitAck_0
    151              {
    152                  SDA_DDR_OUT();
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x....             LDR.N    R1,??DataTable7_3  ;; 0x43fe02b4
   \   00000030   0x6008             STR      R0,[R1, #+0]
    153                  SCL_L();
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x....             LDR.N    R1,??DataTable7_2  ;; 0x43fe0030
   \   00000036   0x6008             STR      R0,[R1, #+0]
    154                  return 0;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xE006             B.N      ??SCCB_WaitAck_1
    155              }
    156              SDA_DDR_OUT();
   \                     ??SCCB_WaitAck_0: (+1)
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x....             LDR.N    R1,??DataTable7_3  ;; 0x43fe02b4
   \   00000040   0x6008             STR      R0,[R1, #+0]
    157              SCL_L();
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x....             LDR.N    R1,??DataTable7_2  ;; 0x43fe0030
   \   00000046   0x6008             STR      R0,[R1, #+0]
    158              return 1;
   \   00000048   0x2001             MOVS     R0,#+1
   \                     ??SCCB_WaitAck_1: (+1)
   \   0000004A   0xBD02             POP      {R1,PC}          ;; return
    159          }
    160          
    161          /*!
    162           *  @brief      SCCB 发送的数据
    163           *  @param      SendByte    需要发送的数据
    164           *  @since      v5.0
    165           */

   \                                 In section .text, align 2, keep-with-next
    166          static void SCCB_SendByte(uint8 SendByte)
    167          {
   \                     SCCB_SendByte: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
    168              uint8 i = 8;
   \   00000004   0x2408             MOVS     R4,#+8
   \   00000006   0xE011             B.N      ??SCCB_SendByte_0
    169              while(i--)
    170              {
    171          
    172                  if(SendByte & 0x80)     //SDA 输出数据
    173                  {
    174                      SDA_H();
    175                  }
    176                  else
    177                  {
    178                      SDA_L();
   \                     ??SCCB_SendByte_1: (+1)
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x....             LDR.N    R1,??DataTable7_1  ;; 0x43fe0034
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    179                  }
    180                  SendByte <<= 1;
   \                     ??SCCB_SendByte_2: (+1)
   \   0000000E   0x006D             LSLS     R5,R5,#+1
    181                  SCCB_DELAY();
   \   00000010   0xF44F 0x70C8      MOV      R0,#+400
   \   00000014   0x.... 0x....      BL       SCCB_delay
    182                  SCL_H();                //SCL 拉高，采集信号
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x....             LDR.N    R1,??DataTable7_2  ;; 0x43fe0030
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    183                  SCCB_DELAY();
   \   0000001E   0xF44F 0x70C8      MOV      R0,#+400
   \   00000022   0x.... 0x....      BL       SCCB_delay
    184                  SCL_L();                //SCL 时钟线拉低
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x....             LDR.N    R1,??DataTable7_2  ;; 0x43fe0030
   \   0000002A   0x6008             STR      R0,[R1, #+0]
   \                     ??SCCB_SendByte_0: (+1)
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0x1E44             SUBS     R4,R0,#+1
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD005             BEQ.N    ??SCCB_SendByte_3
   \   00000036   0x0628             LSLS     R0,R5,#+24
   \   00000038   0xD5E6             BPL.N    ??SCCB_SendByte_1
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x....             LDR.N    R1,??DataTable7_1  ;; 0x43fe0034
   \   0000003E   0x6008             STR      R0,[R1, #+0]
   \   00000040   0xE7E5             B.N      ??SCCB_SendByte_2
    185                  //SCCB_DELAY();
    186              }
    187              //SCL_L();
    188          }
   \                     ??SCCB_SendByte_3: (+1)
   \   00000042   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    189          
    190          /*!
    191           *  @brief      接收SCCB总线的数据
    192           *  @return     接收到的数据
    193           *  @since      v5.0
    194           */

   \                                 In section .text, align 2, keep-with-next
    195          static int SCCB_ReceiveByte(void)
    196          {
   \                     SCCB_ReceiveByte: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    197              uint8 i = 8;
   \   00000002   0x2408             MOVS     R4,#+8
    198              uint8 ReceiveByte = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    199          
    200              //SDA_H();
    201              //SCCB_DELAY();
    202              SDA_DDR_IN();
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x....             LDR.N    R1,??DataTable7_3  ;; 0x43fe02b4
   \   0000000A   0x6008             STR      R0,[R1, #+0]
   \   0000000C   0xE014             B.N      ??SCCB_ReceiveByte_0
    203          
    204              while(i--)
    205              {
    206                  ReceiveByte <<= 1;
   \                     ??SCCB_ReceiveByte_1: (+1)
   \   0000000E   0x006D             LSLS     R5,R5,#+1
    207                  SCL_L();
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x....             LDR.N    R1,??DataTable7_2  ;; 0x43fe0030
   \   00000014   0x6008             STR      R0,[R1, #+0]
    208                  SCCB_DELAY();
   \   00000016   0xF44F 0x70C8      MOV      R0,#+400
   \   0000001A   0x.... 0x....      BL       SCCB_delay
    209                  SCL_H();
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x....             LDR.N    R1,??DataTable7_2  ;; 0x43fe0030
   \   00000022   0x6008             STR      R0,[R1, #+0]
    210                  SCCB_DELAY();
   \   00000024   0xF44F 0x70C8      MOV      R0,#+400
   \   00000028   0x.... 0x....      BL       SCCB_delay
    211          
    212                  if(SDA_IN())
   \   0000002C   0x....             LDR.N    R0,??DataTable7_4  ;; 0x43fe0234
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD001             BEQ.N    ??SCCB_ReceiveByte_0
    213                  {
    214                      ReceiveByte |= 0x01;
   \   00000034   0xF055 0x0501      ORRS     R5,R5,#0x1
    215                  }
    216          
    217          
    218              }
   \                     ??SCCB_ReceiveByte_0: (+1)
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x1E44             SUBS     R4,R0,#+1
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD1E5             BNE.N    ??SCCB_ReceiveByte_1
    219              SDA_DDR_OUT();
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x....             LDR.N    R1,??DataTable7_3  ;; 0x43fe02b4
   \   00000046   0x6008             STR      R0,[R1, #+0]
    220              SCL_L();
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x....             LDR.N    R1,??DataTable7_2  ;; 0x43fe0030
   \   0000004C   0x6008             STR      R0,[R1, #+0]
    221              return ReceiveByte;
   \   0000004E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000050   0x0028             MOVS     R0,R5
   \   00000052   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    222          }
    223          
    224          /*****************************************************************************************
    225          * 函数名：SCCB_WriteByte
    226          * 描述  ：写一字节数据
    227          * 输入  ：- WriteAddress: 待写入地址    - SendByte: 待写入数据  - DeviceAddress: 器件类型
    228          * 输出  ：返回为:=1成功写入,=0失败
    229          * 注意  ：无
    230          *****************************************************************************************/
    231          static int SCCB_WriteByte_one( uint16 WriteAddress , uint8 SendByte );
    232          
    233          

   \                                 In section .text, align 2, keep-with-next
    234          int SCCB_WriteByte( uint16 WriteAddress , uint8 SendByte )            //考虑到用sccb的管脚模拟，比较容易失败，因此多试几次
    235          {
   \                     SCCB_WriteByte: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    236              uint8 i = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    237              while( 0 == SCCB_WriteByte_one ( WriteAddress, SendByte ) )
   \                     ??SCCB_WriteByte_0: (+1)
   \   00000008   0x0029             MOVS     R1,R5
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000010   0x.... 0x....      BL       SCCB_WriteByte_one
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD105             BNE.N    ??SCCB_WriteByte_1
    238              {
    239                  i++;
   \   00000018   0x1C76             ADDS     R6,R6,#+1
    240                  if(i == 20)
   \   0000001A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001C   0x2E14             CMP      R6,#+20
   \   0000001E   0xD1F3             BNE.N    ??SCCB_WriteByte_0
    241                  {
    242                      return 0 ;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xE000             B.N      ??SCCB_WriteByte_2
    243                  }
    244              }
    245              return 1;
   \                     ??SCCB_WriteByte_1: (+1)
   \   00000024   0x2001             MOVS     R0,#+1
   \                     ??SCCB_WriteByte_2: (+1)
   \   00000026   0xBD70             POP      {R4-R6,PC}       ;; return
    246          }
    247          

   \                                 In section .text, align 2, keep-with-next
    248          int SCCB_WriteByte_one( uint16 WriteAddress , uint8 SendByte )
    249          {
   \                     SCCB_WriteByte_one: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    250              if(!SCCB_Start())
   \   00000006   0x.... 0x....      BL       SCCB_Start
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE.N    ??SCCB_WriteByte_one_0
    251              {
    252                  return 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE019             B.N      ??SCCB_WriteByte_one_1
    253              }
    254              SCCB_SendByte( DEV_ADR );                    /* 器件地址 */
   \                     ??SCCB_WriteByte_one_0: (+1)
   \   00000012   0x2042             MOVS     R0,#+66
   \   00000014   0x.... 0x....      BL       SCCB_SendByte
    255              if( !SCCB_WaitAck() )
   \   00000018   0x.... 0x....      BL       SCCB_WaitAck
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD103             BNE.N    ??SCCB_WriteByte_one_2
    256              {
    257                  SCCB_Stop();
   \   00000020   0x.... 0x....      BL       SCCB_Stop
    258                  return 0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xE00E             B.N      ??SCCB_WriteByte_one_1
    259              }
    260              SCCB_SendByte((uint8)(WriteAddress & 0x00FF));   /* 设置低起始地址 */
   \                     ??SCCB_WriteByte_one_2: (+1)
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0x.... 0x....      BL       SCCB_SendByte
    261              SCCB_WaitAck();
   \   00000030   0x.... 0x....      BL       SCCB_WaitAck
    262              SCCB_SendByte(SendByte);
   \   00000034   0x0028             MOVS     R0,R5
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0x.... 0x....      BL       SCCB_SendByte
    263              SCCB_WaitAck();
   \   0000003C   0x.... 0x....      BL       SCCB_WaitAck
    264              SCCB_Stop();
   \   00000040   0x.... 0x....      BL       SCCB_Stop
    265              return 1;
   \   00000044   0x2001             MOVS     R0,#+1
   \                     ??SCCB_WriteByte_one_1: (+1)
   \   00000046   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    266          }
    267          
    268          
    269          
    270          
    271          /******************************************************************************************************************
    272           * 函数名：SCCB_ReadByte
    273           * 描述  ：读取一串数据
    274           * 输入  ：- pBuffer: 存放读出数据  - length: 待读出长度    - ReadAddress: 待读出地址        - DeviceAddress: 器件类型
    275           * 输出  ：返回为:=1成功读入,=0失败
    276           * 注意  ：无
    277           **********************************************************************************************************************/
    278          static int SCCB_ReadByte_one(uint8 *pBuffer,   uint16 length,   uint8 ReadAddress);
    279          

   \                                 In section .text, align 2, keep-with-next
    280          int SCCB_ReadByte(uint8 *pBuffer,   uint16 length,   uint8 ReadAddress)
    281          {
   \                     SCCB_ReadByte: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    282              uint8 i = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    283              while( 0 == SCCB_ReadByte_one(pBuffer, length, ReadAddress) )
   \                     ??SCCB_ReadByte_0: (+1)
   \   0000000A   0x0032             MOVS     R2,R6
   \   0000000C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000E   0x0029             MOVS     R1,R5
   \   00000010   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       SCCB_ReadByte_one
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD105             BNE.N    ??SCCB_ReadByte_1
    284              {
    285                  i++;
   \   0000001C   0x1C7F             ADDS     R7,R7,#+1
    286                  if(i == 30)
   \   0000001E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000020   0x2F1E             CMP      R7,#+30
   \   00000022   0xD1F2             BNE.N    ??SCCB_ReadByte_0
    287                  {
    288                      return 0 ;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xE000             B.N      ??SCCB_ReadByte_2
    289                  }
    290              }
    291              return 1;
   \                     ??SCCB_ReadByte_1: (+1)
   \   00000028   0x2001             MOVS     R0,#+1
   \                     ??SCCB_ReadByte_2: (+1)
   \   0000002A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    292          }
    293          

   \                                 In section .text, align 2, keep-with-next
    294          int SCCB_ReadByte_one(uint8 *pBuffer,   uint16 length,   uint8 ReadAddress)
    295          {
   \                     SCCB_ReadByte_one: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    296              if(!SCCB_Start())
   \   00000008   0x.... 0x....      BL       SCCB_Start
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD101             BNE.N    ??SCCB_ReadByte_one_0
    297              {
    298                  return 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE036             B.N      ??SCCB_ReadByte_one_1
    299              }
    300              SCCB_SendByte( DEV_ADR );         /* 器件地址 */
   \                     ??SCCB_ReadByte_one_0: (+1)
   \   00000014   0x2042             MOVS     R0,#+66
   \   00000016   0x.... 0x....      BL       SCCB_SendByte
    301              if( !SCCB_WaitAck() )
   \   0000001A   0x.... 0x....      BL       SCCB_WaitAck
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD103             BNE.N    ??SCCB_ReadByte_one_2
    302              {
    303                  SCCB_Stop();
   \   00000022   0x.... 0x....      BL       SCCB_Stop
    304                  return 0;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE02B             B.N      ??SCCB_ReadByte_one_1
    305              }
    306              SCCB_SendByte( ReadAddress );           /* 设置低起始地址 */
   \                     ??SCCB_ReadByte_one_2: (+1)
   \   0000002A   0x0030             MOVS     R0,R6
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x.... 0x....      BL       SCCB_SendByte
    307              SCCB_WaitAck();
   \   00000032   0x.... 0x....      BL       SCCB_WaitAck
    308              SCCB_Stop();
   \   00000036   0x.... 0x....      BL       SCCB_Stop
    309          
    310              if(!SCCB_Start())
   \   0000003A   0x.... 0x....      BL       SCCB_Start
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD101             BNE.N    ??SCCB_ReadByte_one_3
    311              {
    312                  return 0;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xE01D             B.N      ??SCCB_ReadByte_one_1
    313              }
    314              SCCB_SendByte( DEV_ADR + 1 );               /* 器件地址 */
   \                     ??SCCB_ReadByte_one_3: (+1)
   \   00000046   0x2043             MOVS     R0,#+67
   \   00000048   0x.... 0x....      BL       SCCB_SendByte
    315          
    316              if(!SCCB_WaitAck())
   \   0000004C   0x.... 0x....      BL       SCCB_WaitAck
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD107             BNE.N    ??SCCB_ReadByte_one_4
    317              {
    318                  SCCB_Stop();
   \   00000054   0x.... 0x....      BL       SCCB_Stop
    319                  return 0;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xE012             B.N      ??SCCB_ReadByte_one_1
    320              }
    321              while(length)
    322              {
    323                  *pBuffer = SCCB_ReceiveByte();
    324                  if(length == 1)
    325                  {
    326                      SCCB_NoAck();
    327                  }
    328                  else
    329                  {
    330                      SCCB_Ack();
   \                     ??SCCB_ReadByte_one_5: (+1)
   \   0000005C   0x.... 0x....      BL       SCCB_Ack
    331                  }
    332                  pBuffer++;
   \                     ??SCCB_ReadByte_one_6: (+1)
   \   00000060   0x1C64             ADDS     R4,R4,#+1
    333                  length--;
   \   00000062   0x1E6D             SUBS     R5,R5,#+1
   \                     ??SCCB_ReadByte_one_4: (+1)
   \   00000064   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000066   0x2D00             CMP      R5,#+0
   \   00000068   0xD008             BEQ.N    ??SCCB_ReadByte_one_7
   \   0000006A   0x.... 0x....      BL       SCCB_ReceiveByte
   \   0000006E   0x7020             STRB     R0,[R4, #+0]
   \   00000070   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000072   0x2D01             CMP      R5,#+1
   \   00000074   0xD1F2             BNE.N    ??SCCB_ReadByte_one_5
   \   00000076   0x.... 0x....      BL       SCCB_NoAck
   \   0000007A   0xE7F1             B.N      ??SCCB_ReadByte_one_6
    334              }
    335              SCCB_Stop();
   \                     ??SCCB_ReadByte_one_7: (+1)
   \   0000007C   0x.... 0x....      BL       SCCB_Stop
    336              return 1;
   \   00000080   0x2001             MOVS     R0,#+1
   \                     ??SCCB_ReadByte_one_1: (+1)
   \   00000082   0xBD70             POP      {R4-R6,PC}       ;; return
    337          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x400FF000         DC32     0x400ff000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x43FE0034         DC32     0x43fe0034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x43FE0030         DC32     0x43fe0030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x43FE02B4         DC32     0x43fe02b4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x43FE0234         DC32     0x43fe0234
    338          
    339          
    340          
    341          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   SCCB_Ack
         8   -> SCCB_delay
      48   SCCB_GPIO_init
        32   -> LPLD_GPIO_Init
        48   -> __aeabi_memcpy4
       8   SCCB_NoAck
         8   -> SCCB_delay
      24   SCCB_ReadByte
        24   -> SCCB_ReadByte_one
      16   SCCB_ReadByte_one
        16   -> SCCB_Ack
        16   -> SCCB_NoAck
        16   -> SCCB_ReceiveByte
        16   -> SCCB_SendByte
        16   -> SCCB_Start
        16   -> SCCB_Stop
        16   -> SCCB_WaitAck
      16   SCCB_ReceiveByte
        16   -> SCCB_delay
      16   SCCB_SendByte
        16   -> SCCB_delay
       8   SCCB_Start
         8   -> SCCB_delay
       8   SCCB_Stop
         8   -> SCCB_delay
       8   SCCB_WaitAck
         8   -> SCCB_delay
      16   SCCB_WriteByte
        16   -> SCCB_WriteByte_one
      16   SCCB_WriteByte_one
        16   -> SCCB_SendByte
        16   -> SCCB_Start
        16   -> SCCB_Stop
        16   -> SCCB_WaitAck
       4   SCCB_delay


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
      60  SCCB_Ack
      52  SCCB_GPIO_init
      60  SCCB_NoAck
      44  SCCB_ReadByte
     132  SCCB_ReadByte_one
      84  SCCB_ReceiveByte
      68  SCCB_SendByte
      94  SCCB_Start
      52  SCCB_Stop
      76  SCCB_WaitAck
      40  SCCB_WriteByte
      72  SCCB_WriteByte_one
      26  SCCB_delay

 
 880 bytes in section .text
 
 880 bytes of CODE memory

Errors: none
Warnings: none
